### Куренков Кирилл ПМИ 3 группа 

# 1. Быстрая сортировка (Quick Sort)

**Quick Sort — это «разделяй и властвуй»‑алгоритм. 
Выбирается опорный элемент (pivot), массив делится на две части: 
элементы меньше pivot и элементы больше pivot, затем рекурсивно сортируются обе части. 
Из‐за небольшого числа сравнений на среднем уровне глубины рекурсии алгоритм очень быстрый на практике.**

_Реализация описана в файле QuickSort.java_

## Алгоритмическая сложность:

* Лучший случай: O(n*log(n))
* 
* Средний случай: O(n*log(n))
* 
* Худший случай: O(n²) (при уже отсортированном или обратно отсортированном массиве и выборе крайних pivot)


# 2. Бинарный поиск (Binary Search)

**Бинарный поиск выполняет поиск элемента в отсортированном массиве, 
последовательно деля область поиска пополам. На каждом шаге сравнивается средний элемент с искомым: 
если он больше — поиск продолжается в левой половине, если меньше — в правой. 
Применяется в системах поиска, при работе с базами данных и в любых задачах, где важно быстро находить элементы в упорядоченных структурах.**

Реализация описана в файле BinarySearch.java

Алгоритмическая сложность:

* Лучший случай: O(1)
* 
* Средний случай: O(log(n))
* 
* Худший случай: O(log(n))


# 3. Алгоритм Дейкстры (Dijkstra's algorithm)

**Алгоритм Дейкстры находит кратчайшие пути от одной вершины до всех остальных в связном взвешенном графе без отрицательных рёбер. 
Использует жадный подход: на каждом шаге выбирает ещё не обработанную вершину с минимальным расстоянием и обновляет расстояния её соседей. 
Широко применяется в навигации, маршрутизации сетевого трафика.**

_Реализация описана в файле Dijkstra.java_

## Алгоритмическая сложность:

При использовании бинарной кучи (PriorityQueue):

Лучший, средний, худший: O((V + E)log(V))
(где V — число вершин, E — число рёбер)


# 4. Алгоритм Крускала (Kruskal’s Algorithm)

Алгоритм Крускала для поиска минимального остовного дерева (Minimum Spanning Tree, MST) в связном взвешенном неориентированном графе.

Описание алгоритма

Основной принцип работы

Берём все рёбра графа и сортируем их по весу в порядке возрастания.

Проходим по этому отсортированному списку рёбер, и для каждого ребра проверяем, не образует ли его добавление цикл в уже строящемся лесу (используем структуру «система непересекающихся множеств» — Union–Find).

Если цикл не образуется, добавляем ребро в остовное дерево; иначе пропускаем.

Продолжаем до тех пор, пока в дереве не будет ровно V–1 рёбер (где V — число вершин).

Где применяется

Построение оптимальных сетей (дороги, коммуникации, электросети).

Задачи кластеризации (агломеративная кластеризация).

Любые задачи, сводимые к поиску минимального остовного дерева.

Особенности алгоритма

Жадный подход: локально выбираем самое «лёгкое» ребро.

Работает эффективно при умеренных размерах графа, когда сортировка рёбер и объединения через Union–Find выполняются быстро.

Требует структуры Union–Find с оптимизациями «ранжирования по рангу» (rank) и «сжатия путей» (path compression).

_Реализация описана в файле Kruskal.java_

## Алгоритмическая сложность алгоритма: Лучший, средний, худший случаи: O(E*Log(V))


# 5. Поиск в ширину (BFS)

**BFS обходит или ищет вершины графа по уровням: сначала все соседи исходной вершины, затем соседи соседей и т.д. 
Реализуется через очередь. Используется для поиска кратчайшего пути в невзвешенном графе, 
тестирования связности, построения остовных деревьев.**

_Реализация описана в файле BFS.java_

## Алгоритмическая сложность: лучший, средний и худший: O(V + E)







